* stack
** API de db-model/lembrando?
*** get-lembrando qa
*** update-lembrando old-lembrando new-data
**** logo um lembrando si precisa remembering-state
*** guardamos o default lembrando?
    nom
** merkle tree
*** as partes que mudam tenhem um pointer às fixas
**** lembrando-state -> lembrando
***** qa
****** user
****** question
****** answer
***** lembrando
****** qa
****** remembering-state
****** due-date
****** failing?
** serialization problems
   depois de importar time-literals:
   (alter-var-root #'*data-readers* assoc
    'time/date #'repro/parse-date
    ...)

*** alter-var-root nippy/*custom-readers* assoc
*** patch read-string...
*** make a new module that includes clojure-only (de)serialization handlers
    by saying data_readers.clj
*** import tick excluding serialization handlers
** ui design
*** smoke test for adding a user
*** smoke test for adding a lembrando
*** add lembrando
    primeiro este?  já tenho todo o que preciso no backend
    pode ser umha seçom
    quando acrescento clear
    no entanto mantenho o estado
    /add
*** edit lembrando
    outra seçom... mais o que passa se clico nela sem mais?
    /edit -> helpful reminder de que nom está implementado search
    podo procurar os IDs no repl or something
    /edit/<lembrando-id>
    nom hai funçom de procurar lembrando por enquanto
    só podo editar os lembrandos que me tocam para o dia
*** review
    /review (sem mais)
    isto pode ser umha seçom
** repetition spacing
*** make sense of sm5
**** single call: sm5/next-state
***** args
****** rate
****** of-matrix (user)
****** remembering-state (user, lembrando)
***** retval
****** days-to-next
****** new-user-state (of-matrix)
****** new-item-state (remembering-state)
**** needs-repeat?
     quando erramos umha questom, chamamos sm5/next-state umha vez só, e entom
     repetimos a questom as vezes que figer falta, mais sem chamar
     sm5/next-state. podo chamar este estado algo assi como failing?
**** quero recuperar of-matrix de perguntas velhas?
nem of-matrix nem item-status; provavelmente as queira reincorporar como
material novo de vez.
*** schema
**** utente
***** nome
***** hashed-password
***** of-matrix
**** lembrando
***** utente
***** pergunta
***** resposta
***** due-date
***** remembering-state
***** failing?
      pode ser true para lembrandos com due-date no futuro, e nesse caso devo
      processá-los imediatamente igual.
**** recall (for logging, attached to txns)
***** utente
***** lembrando
***** rate
*** initialization
**** user
     manual, via REPL
     optimal factor matrix pode ser missing
**** lembrando
     permitir null due date?  sm5 doesn't care.  pero é harder to query for.
     melhor epoch due date.
     remembering state pode ser nil.
*** tempo é importante
    juxt/tick
**** serialization/deserialization
     usar transit ou edn?
     usar readers/writers de tick
          :reader          (transit/reader :json time/time-deserialization-handlers)
          :writer          (transit/writer :json time/time-serialization-handlers)
     https://github.com/luminus-framework/luminus-transit/blob/master/src/luminus_transit/time.cljc
** reorganizar código cljs
   ou ter em screen/tab/section/...?
   nom o tenho claro; por enquanto deixar assi
